"""
Command handler for processing and executing user commands.

This module provides a command processing system with security checks,
error handling, and integration with system utilities and LLM services.
"""
import webbrowser
import os
import sys
import json
import logging
import datetime
from typing import Dict, Callable, List, Optional, Tuple, Union, Any, TypeVar, Type
from pathlib import Path

# Import utilities with proper error handling
try:
    from utils.speech_utils import SpeechSynthesizer, SpeechRecognizer
    from llm.gemini_integration import GeminiChat
    from utils.system_utils import SystemController, SystemCommandError
    from config import Config
    from utils.exceptions import (
        CommandExecutionError,
        CommandValidationError,
        ResourceUnavailableError
    )
except ImportError as e:
    logging.error(f"Failed to import required modules: {e}")
    raise

# Type variable for command handler methods
T = TypeVar('T', bound='CommandHandler')

logger = logging.getLogger(__name__)

class CommandError(Exception):
    """Base exception for command-related errors."""
    def __init__(self, message: str, details: Optional[Dict[str, Any]] = None):
        self.message = message
        self.details = details or {}
        super().__init__(self.message)

class CommandExecutionError(CommandError):
    """Raised when a command fails to execute."""
    pass

class CommandValidationError(CommandError):
    """Raised when command validation fails."""
    pass

class ResourceUnavailableError(CommandError):
    """Raised when a required resource is unavailable."""
    pass

class CommandHandler:
    """Handles command processing and execution with security and error handling."""
    
    def __init__(self, 
                 system_controller: Optional[SystemController] = None,
                 llm_chat: Optional[GeminiChat] = None,
                 speech_synthesizer: Optional[SpeechSynthesizer] = None,
                 speech_recognizer: Optional[SpeechRecognizer] = None):
        """
        Initialize the command handler with required services.
        
        Args:
            system_controller: System controller instance
            llm_chat: LLM chat instance for natural language processing
            speech_synthesizer: Text-to-speech service
            speech_recognizer: Speech recognition service
        """
        self.system_controller = system_controller or SystemController()
        self.llm_chat = llm_chat
        self.speech_synthesizer = speech_synthesizer
        self.speech_recognizer = speech_recognizer
        
        # Initialize state
        self.voice_enabled = True
        self.command_history: List[Dict[str, Any]] = []
        
        # Register commands with their handlers and metadata
        self.commands: Dict[str, Dict[str, Any]] = {
            # Basic commands
            'time': {
                'handler': self._get_current_time,
                'description': 'Get the current time',
                'usage': 'time',
                'needs_voice': False
            },
            'date': {
                'handler': self._get_current_date,
                'description': 'Get the current date',
                'usage': 'date',
                'needs_voice': False
            },
            'search': {
                'handler': self._search_web,
                'description': 'Search the web',
                'usage': 'search [query]',
                'needs_voice': False
            },
            'open': {
                'handler': self._open_application,
                'description': 'Open an application or website',
                'usage': 'open [app/url]',
                'needs_voice': False
            },
            'clear': {
                'handler': self._clear_chat,
                'description': 'Clear the chat history',
                'usage': 'clear',
                'needs_voice': False
            },
            'help': {
                'handler': self._show_help,
                'description': 'Show help information',
                'usage': 'help [command]',
                'needs_voice': False
            },
            'exit': {
                'handler': self._exit_application,
                'description': 'Exit the application',
                'usage': 'exit',
                'needs_voice': False
            },
            
            # System control commands
            'system': {
                'handler': self._system_control,
                'description': 'Control system operations',
                'usage': 'system [shutdown|restart|sleep|lock|hibernate|logout]',
                'needs_voice': False,
                'requires_admin': True
            },
            'processes': {
                'handler': self._list_processes,
                'description': 'List running processes',
                'usage': 'processes',
                'needs_voice': False,
                'requires_admin': True
            },
            'kill': {
                'handler': self._kill_process,
                'description': 'Terminate a process by ID',
                'usage': 'kill [pid]',
                'needs_voice': False,
                'requires_admin': True
            },
            'system_info': {
                'handler': self._get_system_info,
                'description': 'Show system information',
                'usage': 'system_info',
                'needs_voice': False
            },
            
            # Voice control commands
            'voice': {
                'handler': self._toggle_voice,
                'description': 'Toggle voice control',
                'usage': 'voice [on/off]',
                'needs_voice': False
            },
            'listen': {
                'handler': self._listen_command,
                'description': 'Listen for a voice command',
                'usage': 'listen',
                'needs_voice': True
            }
        }
        
        # Initialize voice command mappings
        self.voice_commands = self._initialize_voice_commands()
        
    def _initialize_voice_commands(self) -> Dict[str, str]:
        """Initialize and return the voice command mappings."""
        return {
            # Time and date
            'what time is it': 'time',
            'what is the time': 'time',
            'current time': 'time',
            'tell me the time': 'time',
            'what is today': 'date',
            'what is the date': 'date',
            'current date': 'date',
            "what's the date": 'date',
            
            # Web and applications
            'search the web for': 'search',
            'search for': 'search',
            'look up': 'search',
            'google': 'search',
            'open': 'open',
            'launch': 'open',
            'start': 'open',
            'send an email': 'email',
            'compose email': 'email',
            
            # System controls
            'shutdown': 'system shutdown',
            'shut down': 'system shutdown',
            'turn off': 'system shutdown',
            'power off': 'system shutdown',
            'restart': 'system restart',
            'reboot': 'system restart',
            'sleep': 'system sleep',
            'lock': 'system lock',
            'lock computer': 'system lock',
            'lock my computer': 'system lock',
            'hibernate': 'system hibernate',
            'log out': 'system logout',
            'sign out': 'system logout',
            'log off': 'system logout',
            
            # System info
            'list processes': 'processes',
            'show processes': 'processes',
            'running processes': 'processes',
            'system info': 'system_info',
            'system information': 'system_info',
            'computer info': 'system_info',
            
            # General
            'clear the chat': 'clear',
            'clear chat': 'clear',
            'help me': 'help',
            'show help': 'help',
        
    def _initialize_application_mappings(self) -> Tuple[Dict[str, str], Dict[str, str]]:
        """Initialize and return web and system application mappings."""
        web_apps = {
            'youtube': 'https://youtube.com',
            'google': 'https://google.com',
            'github': 'https://github.com',
            'stackoverflow': 'https://stackoverflow.com',
            'reddit': 'https://reddit.com',
            'twitter': 'https://twitter.com',
            'facebook': 'https://facebook.com',
            'instagram': 'https://instagram.com',
            'linkedin': 'https://linkedin.com',
            'netflix': 'https://netflix.com',
            'amazon': 'https://amazon.com',
            'wikipedia': 'https://wikipedia.org',
        }
        
        system_apps = {
            'notepad': 'notepad.exe',
            'calculator': 'calc.exe',
            'paint': 'mspaint.exe',
            'word': 'winword.exe',
            'excel': 'excel.exe',
            'powerpoint': 'powerpnt.exe',
        }
        
        return web_apps, system_apps
    
    def _match_command(self, command: str) -> tuple:
        """Match a voice command to the best fitting command."""
        command = command.lower().strip()
        
        # Check for direct command match first
        if command in self.commands:
            return command, []
            
        # Check for system actions in the command
        system_actions = ['shutdown', 'restart', 'sleep', 'lock', 'hibernate', 'logout']
        for action in system_actions:
            if action in command:
                return action, []
        
        # Check voice command mappings with priority to longer matches
        best_match = ''
        best_length = 0
        args = []
        
        for voice_cmd, cmd in sorted(self.voice_commands.items(), key=lambda x: -len(x[0])):
            if voice_cmd in command and len(voice_cmd) > best_length:
                best_match = cmd
                best_length = len(voice_cmd)
                # Extract arguments if any
                if len(command) > len(voice_cmd):
                    args = command[command.find(voice_cmd) + len(voice_cmd):].strip().split()
                else:
                    args = []
        
        if best_match:
            return best_match, args
            
        # Try to find similar commands using word matching
        command_words = set(command.split())
        best_similarity = 0
        best_cmd = ''
        
        for cmd in self.commands.keys():
            cmd_words = set(cmd.split())
            similarity = len(command_words.intersection(cmd_words)) / len(command_words.union(cmd_words))
            if similarity > best_similarity and similarity > 0.3:  # Threshold for similarity
                best_similarity = similarity
                best_cmd = cmd
                
        if best_cmd:
            return best_cmd, []
            
        return None, []
    
    def handle_command(self, command: str, *args) -> Union[str, Tuple[bool, str]]:
        """Handle a command with its arguments."""
        if not command:
            return "I didn't catch that. Could you please repeat?"
            
        # First try direct command execution
        if command in self.commands:
            try:
                result = self.commands[command]['handler'](*args)
                if isinstance(result, tuple) and len(result) == 2 and isinstance(result[0], bool):
                    return result[1] if result[0] else f"Error: {result[1]}"
                return result
            except Exception as e:
                logger.error(f"Error executing command '{command}': {e}", exc_info=True)
                return f"I encountered an error executing that command: {e}"
        
        # Try to match the command
        matched_cmd, cmd_args = self._match_command(command)
        
        if matched_cmd:
            try:
                result = self.commands[matched_cmd]['handler'](*cmd_args)
                if isinstance(result, tuple) and len(result) == 2 and isinstance(result[0], bool):
                    return result[1] if result[0] else f"Error: {result[1]}"
                return result
            except Exception as e:
                logger.error(f"Error executing command '{matched_cmd}': {e}", exc_info=True)
                return f"I encountered an error executing that command: {e}"
        
        # If no command matches, use the LLM to generate a response
        return get_chat_response(command)
    
    def _get_current_time(self, *args) -> str:
        """
        Get the current time.
        
        Returns:
            str: Formatted current time
        """
        try:
            current_time = datetime.datetime.now().strftime('%I:%M %p')
            return f"The current time is {current_time}"
        except Exception as e:
            logger.error(f"Error getting current time: {e}")
            return "I couldn't get the current time. Please try again later."
    
    def _get_current_date(self, *args) -> str:
        """
        Get the current date.
        
        Returns:
            str: Formatted current date
        """
        try:
            current_date = datetime.datetime.now().strftime('%A, %B %d, %Y')
            return f"Today is {current_date}"
        except Exception as e:
            logger.error(f"Error getting current date: {e}")
            return "I couldn't get the current date. Please try again later."
    
    def _search_web(self, *args) -> str:
        """
        Search the web using the default browser.
        
        Args:
            *args: Search query terms
            
        Returns:
            str: Status message
            
        Raises:
            CommandExecutionError: If the search fails
        """
        try:
            if not args:
                raise CommandValidationError("Please specify what you'd like to search for.")
            
            # Sanitize query to prevent injection
            query = ' '.join(args).strip()
            if not query:
                raise CommandValidationError("Search query cannot be empty.")
                
            # URL encode the query
            from urllib.parse import quote
            encoded_query = quote(query)
            
            # Construct and open the search URL
            search_url = f"https://www.google.com/search?q={encoded_query}"
            webbrowser.open(search_url)
            
            return f"Searching the web for: {query}"
            
        except webbrowser.Error as e:
            error_msg = f"Failed to open web browser: {e}"
            logger.error(error_msg)
            raise CommandExecutionError("I couldn't open the web browser.") from e
            
        except Exception as e:
            error_msg = f"Error performing web search: {e}"
            logger.error(error_msg)
            raise CommandExecutionError("I encountered an error while searching the web.") from e
    
    def _open_application(self, *args) -> str:
        """
        Open an application or website.
        
        Args:
            *args: Application/website name or path
            
        Returns:
            str: Status message
            
        Raises:
            CommandValidationError: If no target is specified
            CommandExecutionError: If the application/website cannot be opened
        """
        try:
            if not args:
                raise CommandValidationError("Please specify an application or website to open.")
            
            target = args[0].lower().strip()
            if not target:
                raise CommandValidationError("Application/website name cannot be empty.")
            
            # Check if it's a web app
            if target in self.web_apps:
                url = self.web_apps[target]
                try:
                    webbrowser.open(url)
                    return f"Opening {target} in your browser."
                except webbrowser.Error as e:
                    raise CommandExecutionError(
                        f"I couldn't open {target} in your browser.",
                        details={'error': str(e), 'url': url}
                    ) from e
            
            # Check if it's a system app
            if target in self.system_apps:
                app_path = self.system_apps[target]
                try:
                    os.startfile(app_path)
                    return f"Opening {target}..."
                except OSError as e:
                    raise CommandExecutionError(
                        f"I couldn't open {target}.",
                        details={'error': str(e), 'app': target, 'path': app_path}
                    ) from e
            
            # If not found in either, try to open as URL or file path
            try:
                # Check if it looks like a URL
                if any(target.startswith(prefix) for prefix in ('http://', 'https://', 'www.')):
                    url = target if target.startswith('http') else f'https://{target}'
                    webbrowser.open(url)
                    return f"Opening {url} in your browser."
                
                # Try as a file path
                path = Path(target).expanduser().resolve()
                if path.exists():
                    os.startfile(str(path))
                    return f"Opening {path.name}..."
                
                # If we get here, we couldn't identify the target
                suggestions = self._get_suggestions(target)
                if suggestions:
                    suggestion_text = ". Try one of these: " + ", ".join(suggestions)
                else:
                    suggestion_text = ""
                    
                raise CommandValidationError(
                    f"I don't know how to open '{target}'." + suggestion_text,
                    details={'target': target, 'suggestions': suggestions}
                )
                
            except (OSError, webbrowser.Error) as e:
                raise CommandExecutionError(
                    f"I couldn't open '{target}'.",
                    details={'error': str(e), 'target': target}
                ) from e
                
        except Exception as e:
            if not isinstance(e, (CommandValidationError, CommandExecutionError)):
                logger.exception("Unexpected error in _open_application")
                raise CommandExecutionError(
                    "An unexpected error occurred while trying to open that.",
                    details={'error': str(e), 'target': target}
                ) from e
            raise
    
    def _send_email(self, *args) -> str:
        """Send an email (placeholder implementation)."""
        return "I'm sorry, the email functionality is not yet implemented. Would you like me to help you with something else?"
    
    def _clear_chat(self, *args) -> str:
        """Clear the chat history."""
        from llm.gemini_integration import clear_chat_history
        clear_chat_history()
        return "Chat history has been cleared."
    
    def _show_help(self, *args) -> str:
        """Show available commands."""
        help_text = """
        Here are some of the things I can do:
        
        Basic Commands:
        - time: Tell you the current time
        - date: Tell you today's date
        - search [query]: Search the web
        - open [app/website]: Open applications or websites
        - email: Help you send an email
        - clear: Clear our conversation history
        - help: Show this help message
        - exit: Close the application
        
        System Controls:
        - system [action]: Control system actions (shutdown, restart, etc.)
        - shutdown: Shut down the computer
        - restart: Restart the computer
        - sleep: Put the computer to sleep
        - lock: Lock the computer
        - hibernate: Hibernate the computer
        - logout: Log out the current user
        - processes: List running processes
        - kill [pid]: Terminate a process by ID
        - system_info: Show system information
        
        Voice Commands:
        - voice [on/off]: Toggle voice control
        - listen: Listen for a voice command
        
        Just ask me anything or give me a command!
        """
        return help_text
    
    # System control methods
    def _system_control(self, action: str = None) -> Tuple[bool, str]:
        """Handle system control commands."""
        if not action:
            return False, "Please specify a system action (shutdown, restart, sleep, lock, hibernate, logout)"
        
        action = action.lower()
        success, message = control_system(action)
        
        if success:
            if self.voice_enabled:
                speak(f"{action.capitalize()} command sent successfully.")
            return True, f"{action.capitalize()} command sent successfully."
        else:
            error_msg = f"Failed to {action}: {message}"
            if self.voice_enabled:
                speak(error_msg)
            return False, error_msg
    
    def _list_processes(self, *args) -> str:
        """List running processes."""
        processes = get_processes()
        if not processes:
            return "No processes found or error retrieving process list."
        
        # Return first 10 processes as a sample
        process_list = "\n".join([f"{p['pid']}: {p['name']} (User: {p.get('username', 'N/A')})" 
                                 for p in processes[:10]])
        return f"Top 10 running processes:\n{process_list}"
    
    def _kill_process(self, pid: str = None) -> Tuple[bool, str]:
        """Terminate a process by PID."""
        if not pid:
            return False, "Please specify a process ID to terminate."
        
        try:
            pid = int(pid)
            success, message = terminate_process(pid)
            if success:
                if self.voice_enabled:
                    speak(f"Process {pid} terminated successfully.")
                return True, message
            return False, message
        except ValueError:
            return False, f"Invalid process ID: {pid}"
    
    def _get_system_info(self, *args) -> str:
        """Get system information."""
        info = get_system_info()
        if 'error' in info:
            return f"Error getting system info: {info['error']}"
        
        info_text = "\n".join([f"{k.replace('_', ' ').title()}: {v}" for k, v in info.items()])
        return f"System Information:\n{info_text}"
    
    # Voice control methods
    def _toggle_voice(self, state: str = None) -> str:
        """Toggle voice control on/off."""
        if state:
            state = state.lower()
            if state in ['on', 'enable']:
                self.voice_enabled = True
            elif state in ['off', 'disable']:
                self.voice_enabled = False
            else:
                return f"Invalid voice state: {state}. Use 'on' or 'off'."
        else:
            self.voice_enabled = not self.voice_enabled
        
        status = "enabled" if self.voice_enabled else "disabled"
        if self.voice_enabled:
            speak(f"Voice control is now {status}.")
        return f"Voice control is now {status}."
    
    def _listen_command(self, *args) -> str:
        """Listen for a voice command."""
        if not self.voice_enabled:
            return "Voice control is currently disabled. Enable it with 'voice on'."
        
        speak("I'm listening...")
        from utils.speech_utils import listen
        command = listen()
        
        if command and command.lower() not in ['none', '']:
            return self.handle_command(command)
        return "I didn't catch that. Please try again."
    
    def _exit_application(self, *args) -> str:
        """Exit the application."""
        if self.voice_enabled:
            speak("Goodbye! Have a great day!")
        exit(0)

# Initialize command handler
command_handler = CommandHandler()

def process_command(command: str) -> Optional[str]:
    """Process a command string and return the response."""
    if not command or command.lower() in ['', 'none']:
        return None
        
    parts = command.strip().split()
    cmd = parts[0].lower()
    args = parts[1:] if len(parts) > 1 else []
    
    return command_handler.handle_command(cmd, *args)
